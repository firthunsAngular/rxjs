{
  "audit": "      <p>\n          El operador <strong>audit</strong> en RxJS es útil cuando necesitas controlar la emisión de valores en función\n          de un segundo Observable, que representa una \"ventana de tiempo\".\n        </p>\n        <p>\n          Básicamente, audit opera de la siguiente manera:\n        </p>\n        <ol>\n          <li>\n            Tienes un flujo de datos principal, un Observable que emite valores.\n          </li>\n          <li>\n            Junto a él, tienes otro Observable que actúa como un temporizador o un controlador de ventanas de tiempo.\n          </li>\n          <li>\n            <strong>audit</strong> espera a que este segundo Observable emita un valor y solo permite que los valores\n            del flujo principal pasen hacia abajo cuando ocurre esta emisión.\n          </li>\n        </ol>\n        <p>\n          En términos más prácticos, <strong>audit</strong> puede ser útil cuando tienes una secuencia de eventos y solo\n          te interesa obtener el último evento dentro de ciertos intervalos de tiempo. Esto es útil, por ejemplo, para\n          evitar el procesamiento excesivo o innecesario de eventos, especialmente en situaciones donde una ráfaga de\n          eventos ocurre en rápida sucesión.\n        </p>\n        <p>\n          Un ejemplo podría ser un botón que se presiona muchas veces en un corto período y solo te interesa manejar la\n          acción del último botón presionado dentro de cada segundo. <strong>audit</strong> te permitiría capturar solo\n          el último clic dentro de esos intervalos de tiempo.\n        </p>\n        <p>\n          En resumen, <strong>audit</strong> actúa como un filtro temporal, permitiendo pasar solo el último valor del\n          flujo principal dentro de intervalos definidos por otro Observable, lo que puede ayudar a controlar la\n          frecuencia o la cantidad de datos que se procesan.\n        </p>",
  "animationFrames": "  <h5>Ejemplo de uso de animationFrames</h1>\n    <p>\n      El operador <strong>animationFrames</strong> en JavaScript se utiliza para realizar animaciones\n      fluidas en el navegador aprovechando los fotogramas de animación disponibles.\n    </p>\n    <p>\n      Básicamente, permite ejecutar una función en cada fotograma de animación, sincronizándose con la tasa\n      de refresco de la pantalla, lo que es útil para crear animaciones suaves y eficientes.\n    </p>",
  "combineLatest": "<p>\n  El operador <strong>combineLatest</strong> en RxJS es útil cuando necesitas combinar las emisiones más recientes\n  de varios observables en un solo flujo de datos.\n</p>\n<p>\n  Básicamente, <strong>combineLatest</strong> opera así:\n</p>\n<ol>\n  <li>\n    Tienes varios observables emitiendo valores.\n  </li>\n  <li>\n    Cuando al menos uno de estos observables emite un valor, <strong>combineLatest</strong> combina estos valores\n    en un nuevo observable.\n  </li>\n  <li>\n    Este nuevo observable emitirá valores cada vez que cualquiera de los observables de entrada emita un nuevo valor.\n  </li>\n</ol>\n<p>\n  En situaciones prácticas, <strong>combineLatest</strong> puede ser útil cuando necesitas reaccionar a cambios\n  en múltiples fuentes de datos simultáneamente.\n</p>\n<p>\n  Por ejemplo, si tienes dos entradas de datos y necesitas realizar una acción cuando cualquiera de las dos cambie,\n  <strong>combineLatest</strong> te permitirá hacer esto al combinar sus valores más recientes.\n</p>\n<p>\n  En resumen, <strong>combineLatest</strong> toma las emisiones más recientes de varios observables y las combina en\n  un nuevo observable, lo que es útil para reaccionar a cambios simultáneos en múltiples fuentes de datos.\n</p>",
  "combineLatestAll": "<p class=\"mt-3\">\n    El operador <strong>combineLatestAll</strong> en RxJS es útil cuando necesitas combinar los últimos valores\n    emitidos por varios Observables en uno solo.\n</p>\n<p>\n    Básicamente, <strong>combineLatestAll</strong> opera tomando múltiples Observables como entrada y emite un nuevo\n    valor cada vez que alguno de los Observables fuente emite un valor, combinando los últimos valores emitidos por\n    cada uno en un nuevo arreglo.\n</p>\n<p class=\"py-2\">\n    Esto significa que si tienes, por ejemplo, tres Observables A, B y C, <strong>combineLatestAll</strong> emitirá un\n    nuevo valor cuando cualquiera de los Observables A, B o C emita un valor. El valor emitido será un arreglo con los\n    últimos valores emitidos por A, B y C respectivamente.\n</p>\n<p>\n    En términos más prácticos, <strong>combineLatestAll</strong> es útil cuando necesitas trabajar con los últimos\n    valores de múltiples flujos de datos simultáneamente, como por ejemplo, realizar operaciones basadas en la\n    combinación de datos de diferentes fuentes en tiempo real.\n</p>",
  "combineLatestWith": "<p>\n    El operador <strong>combineLatestWith</strong> en RxJS combina los últimos valores emitidos por dos observables.\n  </p>\n  <p>\n    Básicamente, este operador funciona de la siguiente manera:\n  </p>\n  <ol>\n    <li>\n      Tienes dos flujos de datos, dos observables.\n    </li>\n    <li>\n      Cada vez que uno de los observables emite un valor, <strong>combineLatestWith</strong> combina ese valor con el último valor emitido por el otro observable.\n    </li>\n    <li>\n      Se genera un nuevo valor combinado cada vez que alguno de los observables emite un valor.\n    </li>\n  </ol>\n  <p>\n    En términos más prácticos, <strong>combineLatestWith</strong> es útil cuando necesitas trabajar con los últimos valores emitidos por dos flujos de datos y realizar operaciones basadas en esos valores combinados.\n  </p>",
  "concat": "    <h5>Ejemplo de uso de <code>concat</code> en RxJS</h5>\n    <p>\n      El operador <strong>concat</strong> en RxJS se utiliza para combinar observables de manera secuencial.\n    </p>\n    <div class=\"row\">\n      <div class=\"col-md-6\">\n        <h5>Observable 1</h5>\n        <p>Este observable emite valores de manera inicial.</p>\n      </div>\n      <div class=\"col-md-6\">\n        <h5>Observable 2</h5>\n        <p>Este observable se ejecuta después del primero, cuando el primero haya completado su secuencia.</p>\n      </div>\n    </div>",
  "concatAll": "<h5 class=\"mt-4\">Uso de concatAll en RxJS</h5> <p class=\"my-3\">\n  El operador <strong class=\"text-primary\">concatAll</strong> en RxJS se usa para combinar varios observables en uno solo.\n</p>\n<p class=\"my-3\">\n  En términos simples, si tienes un observable que emite otros observables en lugar de valores directos,\n  el <strong class=\"text-primary\">concatAll</strong> los aplanará en un único flujo de datos secuencial.\n</p>",
  "concatMap": "<h5>El operador concatMap en RxJS</h5>\n<p>\n    <strong>concatMap</strong> en RxJS se utiliza para manejar y transformar secuencias de valores provenientes de un Observable, permitiendo la ejecución secuencial de operaciones.\n    Básicamente, cada valor emitido por el Observable es transformado en otro Observable, y concatMap asegura que se respete el orden de emisión de los valores y las operaciones se realicen de manera secuencial.\n</p>\n<p>\n    Por ejemplo, si tienes un flujo de datos principal y quieres aplicar una transformación que devuelve otro Observable para cada valor emitido, concatMap es útil para mantener el orden y la secuencia de esos Observables resultantes.\n</p>\n<p>\n    En resumen, concatMap es una herramienta poderosa para manejar y transformar secuencias de valores en RxJS, asegurando que las operaciones se realicen en orden y de manera secuencial.\n</p>",
  "concatWith": "próximamente...",
  "count": " <h5>Operador Count en RxJS</h5>\n  <p>\n    El operador <strong>count</strong> en RxJS cuenta la cantidad de valores emitidos por un Observable y emite ese recuento como un solo valor en un nuevo Observable.\n  </p>\n  <p>\n    Por ejemplo, si tenemos un Observable que emite una serie de valores:\n  </p>\n  <pre><code class=\"language-javascript\">const numbers$ = Rx.Observable.of(1, 2, 3, 4, 5);</code></pre>\n  <p>\n    Podemos aplicar el operador `count` para contar la cantidad de valores emitidos:\n  </p>\n  <pre><code class=\"language-javascript\">numbers$\n  .pipe(\n    count()\n  )\n  .subscribe(count => {\n    console.log('Cantidad de valores emitidos:', count);\n  });\n  </code></pre>\n  <p>\n    Esto imprimirá en la consola: \"Cantidad de valores emitidos: 5\", ya que el Observable 'numbers$' emitió 5 valores.\n  </p>",

  "debounce": "    <h5>Operador Debounce en RxJS</h5>\n    <p>\n      El operador <strong>debounce</strong> en RxJS es útil cuando necesitas controlar la ejecución de una función en respuesta a eventos como entrada de usuario.\n    </p>\n    <p>\n      Básicamente, debounce espera un cierto tiempo después de que cese una serie de eventos antes de ejecutar una acción.\n    </p>\n    <ol>\n      <li>\n        Tienes una secuencia de eventos, como pulsaciones de teclas, cambios de valores, etc.\n      </li>\n      <li>\n        Usas el operador `debounceTime` para especificar el tiempo que debe transcurrir desde el último evento para que se ejecute la acción.\n      </li>\n    </ol>",
  "debounceTime": " <h5>Ejemplo de debounceTime en RxJS</h5>\n  <p>\n    El operador <strong>debounceTime</strong> en RxJS te permite controlar la emisión de valores en un flujo de datos.\n  </p>\n  <p>\n    Supongamos que tienes un campo de búsqueda:\n  </p>\n  <div class=\"input-group mb-3\">\n    <input type=\"text\" class=\"form-control\" id=\"searchInput\" placeholder=\"Buscar\">\n  </div>\n  <p>\n    Ahora, apliquemos debounceTime al evento de entrada en el campo de búsqueda para realizar la búsqueda después de que el usuario deje de escribir por un tiempo determinado.\n  </p>",
  "defaultEmpty": "hola",
  "defer": "hola",
  "delay": "hola",
  "delayWhen": "hola",
  "dematerialize": "hola",
  "distinct": "hola",
  "distinctUntilChanged": "hola",
  "distinctUntilKeyChanged": "hola",
  "elementAt": "hola",
  "endWith": "hola",
  "every": "hola",
  "exhaustAll": "hola",
  "exhaustMap": "hola",
  "expand": "hola",
  "filter": "hola"
}
