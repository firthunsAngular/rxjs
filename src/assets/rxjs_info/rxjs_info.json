{
  "audit": "      <p>\n          El operador <strong>audit</strong> en RxJS es útil cuando necesitas controlar la emisión de valores en función\n          de un segundo Observable, que representa una \"ventana de tiempo\".\n        </p>\n        <p>\n          Básicamente, audit opera de la siguiente manera:\n        </p>\n        <ol>\n          <li>\n            Tienes un flujo de datos principal, un Observable que emite valores.\n          </li>\n          <li>\n            Junto a él, tienes otro Observable que actúa como un temporizador o un controlador de ventanas de tiempo.\n          </li>\n          <li>\n            <strong>audit</strong> espera a que este segundo Observable emita un valor y solo permite que los valores\n            del flujo principal pasen hacia abajo cuando ocurre esta emisión.\n          </li>\n        </ol>\n        <p>\n          En términos más prácticos, <strong>audit</strong> puede ser útil cuando tienes una secuencia de eventos y solo\n          te interesa obtener el último evento dentro de ciertos intervalos de tiempo. Esto es útil, por ejemplo, para\n          evitar el procesamiento excesivo o innecesario de eventos, especialmente en situaciones donde una ráfaga de\n          eventos ocurre en rápida sucesión.\n        </p>\n        <p>\n          Un ejemplo podría ser un botón que se presiona muchas veces en un corto período y solo te interesa manejar la\n          acción del último botón presionado dentro de cada segundo. <strong>audit</strong> te permitiría capturar solo\n          el último clic dentro de esos intervalos de tiempo.\n        </p>\n        <p>\n          En resumen, <strong>audit</strong> actúa como un filtro temporal, permitiendo pasar solo el último valor del\n          flujo principal dentro de intervalos definidos por otro Observable, lo que puede ayudar a controlar la\n          frecuencia o la cantidad de datos que se procesan.\n        </p>",
  "animationFrames": "  <h5>Ejemplo de uso de animationFrames</h1>\n    <p>\n      El operador <strong>animationFrames</strong> en JavaScript se utiliza para realizar animaciones\n      fluidas en el navegador aprovechando los fotogramas de animación disponibles.\n    </p>\n    <p>\n      Básicamente, permite ejecutar una función en cada fotograma de animación, sincronizándose con la tasa\n      de refresco de la pantalla, lo que es útil para crear animaciones suaves y eficientes.\n    </p>",
  "combineLatest": "<p>\n  El operador <strong>combineLatest</strong> en RxJS es útil cuando necesitas combinar las emisiones más recientes\n  de varios observables en un solo flujo de datos.\n</p>\n<p>\n  Básicamente, <strong>combineLatest</strong> opera así:\n</p>\n<ol>\n  <li>\n    Tienes varios observables emitiendo valores.\n  </li>\n  <li>\n    Cuando al menos uno de estos observables emite un valor, <strong>combineLatest</strong> combina estos valores\n    en un nuevo observable.\n  </li>\n  <li>\n    Este nuevo observable emitirá valores cada vez que cualquiera de los observables de entrada emita un nuevo valor.\n  </li>\n</ol>\n<p>\n  En situaciones prácticas, <strong>combineLatest</strong> puede ser útil cuando necesitas reaccionar a cambios\n  en múltiples fuentes de datos simultáneamente.\n</p>\n<p>\n  Por ejemplo, si tienes dos entradas de datos y necesitas realizar una acción cuando cualquiera de las dos cambie,\n  <strong>combineLatest</strong> te permitirá hacer esto al combinar sus valores más recientes.\n</p>\n<p>\n  En resumen, <strong>combineLatest</strong> toma las emisiones más recientes de varios observables y las combina en\n  un nuevo observable, lo que es útil para reaccionar a cambios simultáneos en múltiples fuentes de datos.\n</p>",
  "combineLatestAll": "<p class=\"mt-3\">\n    El operador <strong>combineLatestAll</strong> en RxJS es útil cuando necesitas combinar los últimos valores\n    emitidos por varios Observables en uno solo.\n</p>\n<p>\n    Básicamente, <strong>combineLatestAll</strong> opera tomando múltiples Observables como entrada y emite un nuevo\n    valor cada vez que alguno de los Observables fuente emite un valor, combinando los últimos valores emitidos por\n    cada uno en un nuevo arreglo.\n</p>\n<p class=\"py-2\">\n    Esto significa que si tienes, por ejemplo, tres Observables A, B y C, <strong>combineLatestAll</strong> emitirá un\n    nuevo valor cuando cualquiera de los Observables A, B o C emita un valor. El valor emitido será un arreglo con los\n    últimos valores emitidos por A, B y C respectivamente.\n</p>\n<p>\n    En términos más prácticos, <strong>combineLatestAll</strong> es útil cuando necesitas trabajar con los últimos\n    valores de múltiples flujos de datos simultáneamente, como por ejemplo, realizar operaciones basadas en la\n    combinación de datos de diferentes fuentes en tiempo real.\n</p>",
  "combineLatestWith": "<p>\n    El operador <strong>combineLatestWith</strong> en RxJS combina los últimos valores emitidos por dos observables.\n  </p>\n  <p>\n    Básicamente, este operador funciona de la siguiente manera:\n  </p>\n  <ol>\n    <li>\n      Tienes dos flujos de datos, dos observables.\n    </li>\n    <li>\n      Cada vez que uno de los observables emite un valor, <strong>combineLatestWith</strong> combina ese valor con el último valor emitido por el otro observable.\n    </li>\n    <li>\n      Se genera un nuevo valor combinado cada vez que alguno de los observables emite un valor.\n    </li>\n  </ol>\n  <p>\n    En términos más prácticos, <strong>combineLatestWith</strong> es útil cuando necesitas trabajar con los últimos valores emitidos por dos flujos de datos y realizar operaciones basadas en esos valores combinados.\n  </p>",
  "concat": "    <h5>Ejemplo de uso de <code>concat</code> en RxJS</h5>\n    <p>\n      El operador <strong>concat</strong> en RxJS se utiliza para combinar observables de manera secuencial.\n    </p>\n    <div class=\"row\">\n      <div class=\"col-md-6\">\n        <h5>Observable 1</h5>\n        <p>Este observable emite valores de manera inicial.</p>\n      </div>\n      <div class=\"col-md-6\">\n        <h5>Observable 2</h5>\n        <p>Este observable se ejecuta después del primero, cuando el primero haya completado su secuencia.</p>\n      </div>\n    </div>",
  "concatAll": "<h5 class=\"mt-4\">Uso de concatAll en RxJS</h5> <p class=\"my-3\">\n  El operador <strong class=\"text-primary\">concatAll</strong> en RxJS se usa para combinar varios observables en uno solo.\n</p>\n<p class=\"my-3\">\n  En términos simples, si tienes un observable que emite otros observables en lugar de valores directos,\n  el <strong class=\"text-primary\">concatAll</strong> los aplanará en un único flujo de datos secuencial.\n</p>",
  "concatMap": "<h5>El operador concatMap en RxJS</h5>\n<p>\n    <strong>concatMap</strong> en RxJS se utiliza para manejar y transformar secuencias de valores provenientes de un Observable, permitiendo la ejecución secuencial de operaciones.\n    Básicamente, cada valor emitido por el Observable es transformado en otro Observable, y concatMap asegura que se respete el orden de emisión de los valores y las operaciones se realicen de manera secuencial.\n</p>\n<p>\n    Por ejemplo, si tienes un flujo de datos principal y quieres aplicar una transformación que devuelve otro Observable para cada valor emitido, concatMap es útil para mantener el orden y la secuencia de esos Observables resultantes.\n</p>\n<p>\n    En resumen, concatMap es una herramienta poderosa para manejar y transformar secuencias de valores en RxJS, asegurando que las operaciones se realicen en orden y de manera secuencial.\n</p>",
  "concatWith": "próximamente...",
  "count": " <h5>Operador Count en RxJS</h5>\n  <p>\n    El operador <strong>count</strong> en RxJS cuenta la cantidad de valores emitidos por un Observable y emite ese recuento como un solo valor en un nuevo Observable.\n  </p>\n  <p>\n    Por ejemplo, si tenemos un Observable que emite una serie de valores:\n  </p>\n  <pre><code class=\"language-javascript\">const numbers$ = Rx.Observable.of(1, 2, 3, 4, 5);</code></pre>\n  <p>\n    Podemos aplicar el operador `count` para contar la cantidad de valores emitidos:\n  </p>\n  <pre><code class=\"language-javascript\">numbers$\n  .pipe(\n    count()\n  )\n  .subscribe(count => {\n    console.log('Cantidad de valores emitidos:', count);\n  });\n  </code></pre>\n  <p>\n    Esto imprimirá en la consola: \"Cantidad de valores emitidos: 5\", ya que el Observable 'numbers$' emitió 5 valores.\n  </p>",
  "debounce": "    <h5>Operador Debounce en RxJS</h5>\n    <p>\n      El operador <strong>debounce</strong> en RxJS es útil cuando necesitas controlar la ejecución de una función en respuesta a eventos como entrada de usuario.\n    </p>\n    <p>\n      Básicamente, debounce espera un cierto tiempo después de que cese una serie de eventos antes de ejecutar una acción.\n    </p>\n    <ol>\n      <li>\n        Tienes una secuencia de eventos, como pulsaciones de teclas, cambios de valores, etc.\n      </li>\n      <li>\n        Usas el operador `debounceTime` para especificar el tiempo que debe transcurrir desde el último evento para que se ejecute la acción.\n      </li>\n    </ol>",
  "debounceTime": " <h5>Ejemplo de debounceTime en RxJS</h5>\n  <p>\n    El operador <strong>debounceTime</strong> en RxJS te permite controlar la emisión de valores en un flujo de datos.\n  </p>\n  <p>\n    Supongamos que tienes un campo de búsqueda:\n  </p>\n  <div class=\"input-group mb-3\">\n    <input type=\"text\" class=\"form-control\" id=\"searchInput\" placeholder=\"Buscar\">\n  </div>\n  <p>\n    Ahora, apliquemos debounceTime al evento de entrada en el campo de búsqueda para realizar la búsqueda después de que el usuario deje de escribir por un tiempo determinado.\n  </p>",
  "defaultEmpty": " <h5>Operador defaultEmpty en RxJS</h5>\n  <p>\n    El operador <strong>defaultEmpty</strong> en RxJS se utiliza para proporcionar un valor por defecto en caso de que un Observable esté vacío al completarse.\n  </p>\n  <p>\n    Es útil cuando deseas asegurarte de que siempre haya al menos un valor emitido, incluso si el Observable no emite nada.\n  </p>",
  "defer": " <h5>El operador <strong>defer</strong> en RxJS</h5>\n  <p>\n    El operador <strong>defer</strong> en RxJS es útil cuando necesitas controlar la emisión de valores en función de un segundo Observable, que representa una \"ventana de tiempo\".\n  </p>\n  <p>\n    Básicamente, <strong>defer</strong> opera de la siguiente manera:\n  </p>\n  <ol>\n    <li>\n      Tienes un flujo de datos principal, un Observable que emite valores.\n    </li>\n    </ol>",
  "delay": "<h5>El operador delay en RxJS</h5>\n<p>\n    El operador <strong>delay</strong> en RxJS es útil cuando necesitas controlar la emisión de valores en función\n    de un segundo Observable, que representa una \"ventana de tiempo\".\n</p>\n<p>\n    Básicamente, el operador delay opera de la siguiente manera:\n</p>\n<ol>\n    <li>\n        Tienes un flujo de datos principal, un Observable que emite valores.\n    </li>\n </ol>\n",
  "delayWhen": " <h5>Operador delayWhen en RxJS</h5>\n  <p>\n    El operador <strong>delayWhen</strong> en RxJS es útil cuando necesitas controlar la emisión de valores en función de un segundo Observable, que representa una \"ventana de tiempo\".\n  </p>\n  <p>\n    Básicamente, delayWhen opera de la siguiente manera:\n  </p>\n  <ol>\n    <li>\n      Tienes un flujo de datos principal, un Observable que emite valores.\n    </li>\n    <li>\n      También tienes otro Observable que actúa como un temporizador o una señal para retrasar la emisión de esos valores.\n    </li>\n    <li>\n      Cuando el segundo Observable emite un valor, delayWhen espera hasta entonces para propagar el valor del flujo de datos principal.\n    </li>\n  </ol>\n  <p>\n    Esto es especialmente útil cuando necesitas controlar el tiempo entre emisiones de valores en tu flujo de datos observables.\n  </p>",
  "distinct": "<h5>El operador distinct en RxJS</h5>\n<p>\n    El operador <strong>distinct</strong> en RxJS es útil cuando necesitas controlar la emisión de valores en función\n    de un segundo Observable, que representa una \"ventana de tiempo\".\n</p>\n<p>\n    Básicamente, distinct opera de la siguiente manera:\n</p>\n<ol>\n    <li>\n        Tienes un flujo de datos principal, un Observable que emite valores.\n    </li>\n    <li>\n        Cuando usas el operador `distinct`, este observa los valores que emite ese flujo de datos y solo emite aquellos\n        que son diferentes de los que ha emitido anteriormente.\n    </li>\n    <li>\n        Los valores duplicados no se emiten; solo se emite el primer valor y los valores posteriores que son únicos.\n    </li>\n</ol>\n",
  "elementAt": "<div class=\"container\">\n  <h5>Operador elementAt en RxJS</h5>\n  <p>\n    El operador <strong>elementAt</strong> en RxJS es útil cuando necesitas acceder a un valor específico emitido por un Observable en una posición determinada.\n  </p>\n  <p>\n    Básicamente, `elementAt` opera de la siguiente manera:\n  </p>\n  <ol>\n    <li>\n      Tienes un flujo de datos principal, un Observable que emite valores.\n    </li>\n    <li>\n      Luego, utilizas el operador `elementAt` y le pasas el índice del valor que deseas obtener.\n    </li>\n    <li>\n      El operador `elementAt` emitirá el valor que se encuentra en la posición indicada dentro del flujo de datos.\n    </li>\n  </ol>\n  <p>\n    Puedes utilizar este operador cuando necesitas acceder a un valor específico dentro de un flujo de datos Observable en lugar de recibir todos los valores emitidos.\n  </p>\n</div>\n",
  "endWith": "<h5>Operador endWith en RxJS</h5>\n<p>\n    El operador <strong>endWith</strong> en RxJS es útil cuando necesitas controlar la emisión de valores en función\n    de un segundo Observable, que representa una \"ventana de tiempo\".\n</p>\n<p>\n    Básicamente, el operador <strong>endWith</strong> opera de la siguiente manera:\n</p>\n<ol>\n    <li>\n        Tienes un flujo de datos principal, un Observable que emite valores.\n    </li>\n    <li>\n        Utilizas <code>endWith(valor)</code> para añadir un valor específico al final de este flujo de datos.\n    </li>\n    <li>\n        Una vez que el flujo de datos principal ha concluido su emisión, se añade el valor especificado por <code>endWith</code> al final.\n    </li>\n</ol>\n",
  "every": "<h5>Operador 'every' en RxJS</h5>\n<p>\n    El operador <strong>'every'</strong> en RxJS es útil cuando necesitas verificar si todos los elementos emitidos por un Observable cumplen con una condición específica.\n</p>\n<p>\n    Básicamente, el operador 'every' opera de la siguiente manera:\n</p>\n<ol>\n    <li>\n        Tienes un flujo de datos principal, un Observable que emite valores.\n    </li>\n    <li>\n        Aplicas el operador 'every' a este Observable.\n    </li>\n    <li>\n        Cada vez que el Observable emite un valor, el operador 'every' verifica si todos los elementos emitidos hasta ese momento cumplen con la condición proporcionada.\n    </li>\n    <li>\n        Si todos los elementos cumplen con la condición, el Observable resultante emitirá un valor booleano <code>true</code>; de lo contrario, emitirá <code>false</code>.\n    </li>\n</ol>\n",
  "exhaustAll": "  <h5>Operador exhaustAll en RxJS</h5>\n  <p>\n    El operador <strong>exhaustAll</strong> en RxJS es útil cuando necesitas controlar la emisión de valores en función de un segundo Observable, que representa una \"ventana de tiempo\".\n  </p>\n  <p>\n    Básicamente, el operador <strong>exhaustAll</strong> opera de la siguiente manera:\n  </p>\n  <ol>\n    <li>\n      Tienes un flujo de datos principal, un Observable que emite valores.\n    </li>\n   \n  </ol>\n<ol>\n  <li>\n    Tienes un flujo de datos principal, un Observable que emite valores.\n  </li>\n  <li>\n    Cuando este flujo emite un valor, el operador `exhaustAll` verifica si hay otro Observable activo.\n  </li>\n  <li>\n    Si hay otro Observable secundario (ventana de tiempo) en curso, `exhaustAll` ignora los valores del flujo principal hasta que esa ventana de tiempo se complete.\n  </li>\n  \n</ol>\n",
  "exhaustMap": "<h5>Uso de exhaustMap en RxJS</h5>\n<p>\n    El operador <strong>exhaustMap</strong> en RxJS es útil cuando deseas controlar el flujo de datos.\n    Permite manejar las emisiones de un observable secundario solo si no hay otros activos en ese momento.\n    Por ejemplo, si estás manejando eventos como clics y quieres realizar acciones basadas en estos eventos,\n    pero evitando ejecuciones superpuestas, el exhaustMap es una herramienta poderosa para ello.\n</p>\n",



  "firstValueFrom": "<h5>Operador firstValueFrom en RxJS</h5>\n<p>\n  El operador <strong>firstValueFrom</strong> en RxJS es útil cuando quieres obtener el primer valor emitido por un observable y convertirlo en una promesa.\n</p>\n",
  "filter": "<h5>Operador Filter en RxJS</h5>\n<p>\n  El operador <strong>filter</strong> en RxJS es útil cuando deseas filtrar elementos\n  de una secuencia observable basado en ciertas condiciones.\n</p>\n\n<!-- Ejemplo de uso del operador filter -->\n<div>\n  <h6>Ejemplo: Filtrar números pares</h6>\n  <p>\n    Supongamos que tenemos un flujo de números y queremos filtrar solo los números pares.\n  </p>\n\n  <!-- Aquí simularemos un flujo de números -->\n  <div id=\"output\"></div>\n</div>\n\n<!-- Script para demostrar el operador filter -->\n<script>\n  const { from } = rxjs;\n  const { filter } = rxjs.operators;\n\n  // Creamos un flujo de números del 1 al 10\n  const numeros = from([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);\n\n  // Aplicamos el operador filter para filtrar solo los números pares\n  const numerosPares = numeros.pipe(\n    filter(numero => numero % 2 === 0)\n  );\n\n  // Mostramos los números pares en el HTML utilizando Bootstrap\n  const output = document.getElementById('output');\n  numerosPares.subscribe(\n    numero => {\n      const elemento = document.createElement('span');\n      elemento.classList.add('badge', 'badge-primary', 'mx-1');\n      elemento.textContent = numero;\n      output.appendChild(elemento);\n    }\n  );\n</script>\n",
  "find": "<div class=\"container\">\n  <h5>Operador find en RxJS</h5>\n  <p>\n    El operador <strong>find</strong> en RxJS es útil cuando necesitas encontrar el primer elemento que cumpla con cierta condición dentro de un flujo de datos observable.\n  </p>\n</div>\n",
  "findIndex": "<h5>Operador findIndex en RxJS</h5>\n<p>\n  El operador <strong>findIndex</strong> en RxJS es útil cuando necesitas encontrar el índice del primer elemento que cumple con una condición específica dentro de un flujo de datos observable.\n</p>\n<p>\n  Por ejemplo, si tenemos un flujo de números:\n</p>\n<pre><code>\nconst numeros$ = Rx.Observable.of(2, 8, 4, 10, 7);\n</code></pre>\n<p>\n  Podemos utilizar <code>findIndex</code> para encontrar el índice del primer número mayor que 5:\n</p>\n<pre><code>\nnumeros$\n  .pipe(\n    rxjs.operators.findIndex(num => num > 5)\n  )\n  .subscribe(indice => {\n    if (indice !== -1) {\n      console.log(`El índice del primer número mayor que 5 es: ${indice}`);\n    } else {\n      console.log('No se encontró ningún número que cumpla la condición.');\n    }\n  });\n</code></pre>\n",
  "first": "<h5>Operador \"first\" en RxJS</h5>\n<p>\n    El operador <strong>first</strong> en RxJS es útil cuando se desea obtener el primer valor emitido por un observable y luego completar la suscripción.\n</p>\n",
  "forkJoin": "<h5>El operador <strong>forkJoin</strong> en RxJS</h5>\n<p>Es útil cuando necesitas combinar múltiples observables y esperar a que todos terminen para emitir sus valores combinados como una única emisión.</p>\n",
  "from": "<div class=\"container\">\n  <h5>El operador <strong>from</strong> en RxJS</h5>\n  <p>\n    El operador <strong>from</strong> en RxJS es una herramienta fundamental. Permite transformar una amplia gama de estructuras en observables, lo que facilita la manipulación y el flujo de datos en la programación reactiva.\n  </p>\n  <!-- Aquí puedes seguir con más detalles sobre cómo se usa, ejemplos prácticos, etc. -->\n</div>\n",
  "fromEvent": "<div class=\"container\">\n  <h5>Evento con RxJS</h5>\n  <p>\n    El operador <strong>fromEvent</strong> en RxJS es útil cuando necesitas\n    convertir eventos DOM, como clics o cambios, en observables para un manejo\n    más sencillo y poderoso.\n  </p>\n  <button id=\"myButton\" class=\"btn btn-primary\">Haz clic aquí</button>\n</div>\n",
  "groupBy": "<div class=\"container\">\n  <h5>Operador `groupBy` en RxJS</h5>\n  <p>\n    El operador <strong> `groupBy` </strong> en RxJS es útil cuando necesitas dividir un flujo de datos en subgrupos\n    basados en criterios específicos.\n  </p>\n\n  <p>\n    Por ejemplo, si tienes un flujo de números y deseas agruparlos en pares e impares, podrías hacer lo siguiente:\n  </p>\n\n  <pre><code>\n    const { from } = rxjs;\n    const { groupBy, mergeMap, toArray } = rxjs.operators;\n\n    // Flujo de números\n    const numeros = from([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);\n\n    // Agrupar números pares e impares\n    const grupoNumeros = numeros.pipe(\n      groupBy(num => num % 2 === 0 ? 'par' : 'impar'),\n      mergeMap(grupo => grupo.pipe(toArray()))\n    );\n\n    grupoNumeros.subscribe(grupo => {\n      console.log('Grupo:', grupo);\n    });\n  </code></pre>\n\n  <p>\n    En este ejemplo, el operador `groupBy` se utiliza para dividir los números en dos grupos: pares e impares.\n    Luego, se usan operadores adicionales para trabajar con cada grupo, en este caso, `mergeMap` y `toArray`.\n  </p>\n</div>\n",
  "last": "<div class=\"container\">\n  <h5>Operador Last en RxJS</h5>\n  <p>\n    El operador <strong>last</strong> en RxJS es útil cuando necesitas obtener el último valor emitido por un observable antes de que se complete.\n  </p>\n</div>\n",
  "lastValueFrom": "<!-- Estilos de Bootstrap -->\n<h5 class=\"my-3\">Operador lastValueFrom en RxJS</h5>\n<p>\n  El operador \n  <strong>lastValueFrom</strong> \n  en RxJS es útil cuando necesitas obtener el último valor emitido por un observable y convertirlo en una promesa para trabajar de manera sincrónica con datos asincrónicos.\n</p>\n",
  "map": "<h5>Operador <strong>map</strong> en RxJS</h5>\n<p>\n    El operador <strong>map</strong> en RxJS es útil cuando necesitas transformar los valores emitidos por un observable en otros valores, permitiéndote realizar operaciones o ajustes a los datos de manera sencilla.\n</p>\n",
  "merge": "<h5>Operador Merge en RxJS</h5>\n<p>\n  El operador <strong>merge</strong> en RxJS es útil cuando deseas combinar múltiples observables en uno solo para trabajar con múltiples flujos de datos.\n</p>\n",
  "mergeAll": "<div class=\"container\">\n  <h5>Combinando flujos de datos con RxJS mergeAll</h5>\n  <p>\n    El operador <strong>mergeAll</strong> en RxJS es útil cuando tienes varios observables y quieres trabajar con ellos como un único flujo de datos.\n  </p>\n \n</div>\n",
  "mergeMap": "<div class=\"container\">\n  <h5>Operador mergeMap en RxJS</h5>\n  <p>\n    El operador <strong>mergeMap</strong> en RxJS es útil cuando necesitas trabajar con múltiples observables.\n    Permite tomar un observable y transformarlo en otro, lo que resulta especialmente útil para manejar\n    múltiples fuentes de datos de manera concurrente y combinar sus resultados en un solo flujo de datos.\n    Esto es útil en situaciones donde necesitas realizar peticiones HTTP simultáneas o trabajar con\n    flujos de datos complejos.\n  </p>\n</div>\n",
  "min": "<div class=\"container\">\n  <h5>Operador min en RxJS</h5>\n  <p>\n    El operador <strong>min</strong> en RxJS es útil cuando necesitas encontrar el valor más pequeño en un flujo de datos observables.\n  </p>\n</div>\n",
  "of": "<div class=\"container\">\n  <h5>Ejemplo de uso del operador <strong>of</strong> en RxJS</h5>\n  <p>\n    El operador <strong>of</strong> en RxJS es útil cuando necesitas crear un observable que emita una secuencia de valores predeterminados.\n  </p>\n</div>\n",
  "pipe": "<h5>Ejemplo de uso de operador pipe en RxJS</h5>\n<p>\n    El operador <strong>pipe</strong> en RxJS es útil cuando quieres aplicar una serie de operaciones a un flujo de datos observable.\n</p>\n",
  "race": "<div class=\"container\">\n  <h5>Operador <strong>race</strong> en RxJS</h5>\n  <p>\n    El operador <strong>race</strong> en RxJS es útil cuando necesitas obtener el valor del primer observable\n    que emita un evento entre varios observables simultáneamente.\n  </p>\n</div>\n",
  "range": "<h5>Operador range en RxJS</h5>\n<p>\n    El operador <strong>range</strong> en RxJS es útil cuando necesitas generar una secuencia de números dentro de un rango específico.\n    Este operador crea un observable que emite una serie de números desde un valor inicial hasta un valor final, opcionalmente con un paso definido.\n    Por ejemplo:\n</p>\n\n<div class=\"container\">\n    <div class=\"row\">\n        <div class=\"col-md-6\">\n            <h6>Ejemplo en TypeScript</h6>\n            <pre>\n                <code>\n                    import { range } from 'rxjs';\n\n                    // Emite números del 1 al 5\n                    const example = range(1, 5);\n\n                    example.subscribe(val => console.log(val));\n                    // Resultado: 1, 2, 3, 4, 5\n                </code>\n            </pre>\n        </div>\n        <div class=\"col-md-6\">\n            <h6>Ejemplo en HTML</h6>\n            <p>\n                También puedes usar el operador <code>range</code> en combinación con otros operadores de RxJS para manipular y transformar los valores emitidos.\n            </p>\n        </div>\n    </div>\n</div>\n",
  "reduce": "<div class=\"container\">\n    <h5>Operador reduce en RxJS</h5>\n    <p>\n        El operador <strong>reduce</strong> en RxJS es útil cuando necesitas combinar todos los elementos de un flujo observable en un único resultado final.\n        Por ejemplo, supongamos que tienes un flujo de números:\n    </p>\n    <ul class=\"list-group\">\n        <li class=\"list-group-item\">1</li>\n        <li class=\"list-group-item\">2</li>\n        <li class=\"list-group-item\">3</li>\n        <li class=\"list-group-item\">4</li>\n    </ul>\n    <p>\n        Si aplicas el operador <code>reduce</code> con una función que sume estos números, obtendrás el resultado final:\n    </p>\n    <div class=\"alert alert-info\" role=\"alert\">\n        Resultado de reduce: <strong>10</strong> (1 + 2 + 3 + 4)\n    </div>\n    <p>\n        En este caso, el operador <code>reduce</code> toma cada número del flujo y lo combina con el acumulador, que es el resultado parcial de la operación anterior.\n        Esto se repite hasta que todos los elementos del flujo se han procesado, produciendo un único valor final.\n    </p>\n</div>\n",
  "retry": "<h5>Operador retry en RxJS</h5>\n<p>\n    El operador <strong>retry</strong> en RxJS es útil cuando quieres que un observable se vuelva a suscribir automáticamente después de que ocurra un error.\n</p>\n",
  "sample": "<div class=\"container\">\n  <h5>Operador <strong>sample</strong> en RxJS</h5>\n  <p>\n    El operador <strong>sample</strong> en RxJS es útil cuando necesitas capturar el último valor emitido por un flujo de datos en intervalos específicos de tiempo.\n  </p>\n</div>\n",
  "skip": "<div class=\"container\">\n  <h5>Operador Skip en RxJS</h5>\n  <p>\n    El operador <strong>skip</strong> en RxJS es útil cuando quieres ignorar los primeros elementos de un flujo de datos.\n  </p>\n</div>\n",
  "skipLast": "<div class=\"container\">\n  <h5>Operador skipLast en RxJS</h5>\n  <p>\n    El operador <strong>skipLast</strong> en RxJS es útil cuando necesitas omitir los últimos elementos de un flujo de datos observable.\n  </p>\n</div>\n",
  "skipUntil": "<div class=\"container\">\n    <h5 class=\"mt-4 mb-2\">El operador skipUntil en RxJS</h5>\n    <p>\n        El operador <strong>skipUntil</strong> en RxJS es útil cuando necesitas\n        esperar a que un Observable emita su primer valor para empezar a recibir\n        valores de otro Observable, ignorando los valores previos.\n    </p>\n</div>\n",
  "skipWhile": "<h5>Operador skipWhile en RxJS</h5>\n<p>\n  El operador <strong>skipWhile</strong> en RxJS es útil cuando necesitas\n  omitir valores de un flujo de datos hasta que se cumpla una condición\n  específica. Por ejemplo, puedes saltar valores hasta que encuentres un\n  elemento que satisfaga cierta condición, como ignorar números menores o\n  iguales a 5 en un flujo de números.\n</p>\n",
  "switchAll": "<h5>Operador switchAll en RxJS</h5>\n<p>\n  El operador <strong>switchAll</strong> en RxJS es útil cuando trabajas con flujos de datos\n  donde cada emisión es un <em>observable</em>. Permite suscribirse al observable más reciente,\n  ignorando los anteriores. Esto es útil cuando tienes múltiples observables y solo te interesa\n  el último emitido.\n</p>\n",
  "switchMap": "<h5>Uso de switchMap en RxJS</h5>\n<p>\n    El operador <strong>switchMap</strong> en RxJS es útil cuando necesitas cambiar a un nuevo observable \n    basado en los valores emitidos por otro observable, cancelando cualquier suscripción anterior.\n</p>\n",
  "take": "<div class=\"container\">\n  <h5>Operador Take en RxJS</h5>\n  <p>\n    El operador <strong>take</strong> en RxJS es útil cuando deseas limitar la cantidad de elementos\n    emitidos por un Observable. Por ejemplo:\n  </p>\n  <div class=\"card\">\n    <div class=\"card-body\">\n      <h6 class=\"card-title\">Ejemplo de uso de take</h6>\n      <p class=\"card-text\">\n        Supongamos que tenemos un Observable que emite números:\n      </p>\n      <pre><code class=\"language-javascript\">\n        const { from } = rxjs;\n        const { take } = rxjs.operators;\n\n        const numeros$ = from([1, 2, 3, 4, 5, 6, 7]);\n\n        numeros$.pipe(\n          take(3) // Tomamos solo los primeros 3 elementos\n        ).subscribe(numero => {\n          console.log(numero); // Aquí se mostrarán solo los 3 primeros números emitidos\n        });\n      </code></pre>\n    </div>\n  </div>\n</div>\n",
  "timeout": "<h5 class=\"text-primary\">Timeout en RxJS</h5>\n<p class=\"text-muted\">\n    El operador <strong>timeout</strong> en RxJS es útil cuando quieres establecer un límite de tiempo\n    para la finalización de una operación en tus flujos de datos. Esto es especialmente útil\n    cuando necesitas asegurarte de que cierto evento ocurra dentro de un tiempo determinado.\n</p>\n",

  "behaviorSubject": " <div class=\"container mt-4\">\n    <h5>Clase BehaviorSubject en RxJS</h5>\n    <p>\n      La clase BehaviorSubject es como una caja que guarda un valor. Lo interesante es que siempre puedes ver el valor más reciente sin alterar lo que hay dentro de la caja.\n    </p>\n    <p>\n      Imagina que tienes una caja que guarda tu número favorito. Cada vez que alguien te pregunta cuál es tu número favorito, puedes abrir la caja y verlo sin cambiar el número guardado. Además, si decides cambiar tu número favorito, puedes actualizarlo dentro de la misma caja para que esté disponible la próxima vez que alguien pregunte.\n    </p>\n    <p>\n      De manera similar, BehaviorSubject guarda un valor y puedes obtener ese valor en cualquier momento sin alterarlo. También puedes actualizar este valor, y todas las partes de tu código que estén suscritas a este BehaviorSubject recibirán automáticamente el nuevo valor.\n    </p>\n    <p>\n      Es útil en situaciones donde necesitas compartir y actualizar un valor entre diferentes partes de tu aplicación Angular, ya que las actualizaciones se propagan automáticamente a todos los suscriptores.\n    </p>\n  </div>",
  "observable": " <div class=\"container\">\n    <div class=\"row\">\n      <div class=\"col-md-8 offset-md-2\">\n        <div class=\"explanation\">\n          <h5>Explicación de Observable en RxJS</h5>\n          <p>\n            RxJS es una librería que implementa el patrón de Observables. Un Observable es como una corriente de eventos que pueden ser consumidos por uno o más observadores.\n          </p>\n          <p>\n            Imagina un Observable como una fuente de datos que puede emitir múltiples valores en el tiempo. Estos valores pueden ser números, strings, objetos, eventos, etc.\n          </p>\n          <p>\n            Los Observables pueden ser manipulados mediante operadores como map, filter, reduce, etc., permitiendo transformar, filtrar o combinar los datos que emiten.\n          </p>\n          <p>\n            Además, los Observables tienen métodos como <code>subscribe()</code> que permite a un observador suscribirse para recibir y manejar los valores emitidos por el Observable.\n          </p>\n          <p>\n            En resumen, los Observables en RxJS son como flujos de datos que pueden ser observados, transformados y consumidos por diferentes partes de una aplicación.\n          </p>\n        </div>\n      </div>\n    </div>\n  </div>",
  "replaySubject": " <div class=\"container\">\n    <h5>Explicación de ReplaySubject en RxJS</h5>\n    <div class=\"explanation\">\n      <h5>¿Qué es ReplaySubject en RxJS?</h5>\n      <p>ReplaySubject es un tipo de sujeto en RxJS que almacena un historial de valores emitidos.</p>\n      <p>Los futuros suscriptores pueden recibir tanto los nuevos valores como los valores anteriores emitidos por el ReplaySubject.</p>\n    </div>\n  </div>",
  "subject": "<div class=\"container mt-5\">\n    <h5>Clase RxJS Subject</h5>\n    <p>\n      La clase <strong>Subject</strong> en RxJS es como un puente que conecta un observador (algo que está pendiente de un evento) con un observable (la fuente de esos eventos). Funciona como un emisor de eventos y a la vez como un observable que permite la subscripción de múltiples observadores.\n    </p>\n    <p>\n      Los <strong>Subjects</strong> son como observables multicasting. Pueden tener muchos suscriptores, y al mismo tiempo, se pueden suscribir a otra fuente de eventos.\n    </p>\n    <p>\n      Para utilizar un <strong>Subject</strong>, primero se instancia con <code>new Subject()</code>. Luego puedes subscribirte a él con el método <code>subscribe()</code> y emitir eventos usando <code>next()</code>.\n    </p>\n  </div>",
  "subscription": "<div class=\"container mt-4\">\n  <div class=\"card\">\n    <div class=\"card-body\">\n      <h5 class=\"card-title\">Clase Subscription en RxJS</h5>\n      <p class=\"card-text\">\n        La clase Subscription en RxJS es utilizada para manejar suscripciones a observables.\n        Cuando te suscribes a un Observable, la Subscription representa la conexión entre el Observable y el observador.\n        Puedes usar el método unsubscribe() para liberar los recursos una vez que hayas terminado de usar el Observable.\n        Esto es crucial para prevenir posibles pérdidas de memoria o fugas.\n      </p>\n    </div>\n  </div>\n</div>"
}
